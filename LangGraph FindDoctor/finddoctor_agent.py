from typing import List, Dict, Any, Optional, TypedDict
from langchain.tools import tool
from langchain_core.messages import HumanMessage, SystemMessage, AIMessage, ToolMessage
from langchain_openai import ChatOpenAI
from langgraph.graph import StateGraph, END, MessagesState
from langgraph.prebuilt import ToolNode
from langgraph.checkpoint.memory import MemorySaver
import json
import os

from finddoctor_api_client import FindDoctorApiClient

# Inicializa o cliente da API
client = FindDoctorApiClient("http://localhost:5210")

# Define o estado do agente usando MessagesState padr√£o
# MessagesState j√° inclui a lista de mensagens com add_messages

# Define as ferramentas
@tool
def search_address(query: str) -> str:
    """Busca por um endere√ßo e retorna informa√ß√µes de geolocaliza√ß√£o."""
    print(f"üîç EXECUTANDO: search_address com query='{query}'")
    try:
        results = client.search_address(query)
        if not results:
            print("   ‚ùå Nenhum endere√ßo encontrado")
            return "Nenhum endere√ßo encontrado para esta consulta."
        print(f"   ‚úÖ {len(results)} endere√ßo(s) encontrado(s)")
        return json.dumps(results[:3], ensure_ascii=False)
    except Exception as e:
        return f"Erro ao buscar endere√ßo: {str(e)}"

@tool
def get_specialties() -> str:
    """Obt√©m a lista de todas as especialidades m√©dicas dispon√≠veis do arquivo local filtrado."""
    print(f"üè• EXECUTANDO: get_specialties (arquivo m√©dico filtrado)")
    try:
        # Caminho para o arquivo JSON de especialidades m√©dicas filtrado
        json_file_path = os.path.join(os.path.dirname(__file__), "medical_specialties.json")
        
        # Verifica se o arquivo existe
        if not os.path.exists(json_file_path):
            print(f"   ‚ùå Arquivo {json_file_path} n√£o encontrado")
            return "Erro: Arquivo de especialidades m√©dicas n√£o encontrado."
        
        # L√™ o arquivo JSON local filtrado
        with open(json_file_path, 'r', encoding='utf-8') as file:
            specialties = json.load(file)
        
        print(f"   ‚úÖ {len(specialties)} especialidade(s) m√©dica(s) carregada(s) do arquivo filtrado")
        return json.dumps(specialties, ensure_ascii=False)
        
    except Exception as e:
        print(f"   ‚ùå Erro ao ler arquivo de especialidades m√©dicas: {str(e)}")
        return f"Erro ao buscar especialidades m√©dicas: {str(e)}"

@tool
def search_establishments(
    latitude: float,
    longitude: float,
    radius_km: float = 5,
    specialty_name: Optional[str] = None,
    doctor_name: Optional[str] = None
) -> str:
    """
    Busca estabelecimentos de sa√∫de pr√≥ximos √†s coordenadas especificadas.
    
    Argumentos:
        latitude: Coordenada de latitude
        longitude: Coordenada de longitude
        radius_km: Raio de busca em quil√¥metros
        specialty_name: Nome da especialidade m√©dica (ex: "cardiologista", "pediatra")
        doctor_name: Nome opcional do m√©dico para filtrar resultados    """
    print(f"üè¢ EXECUTANDO: search_establishments")
    print(f"   üìç Localiza√ß√£o: ({latitude}, {longitude})")
    print(f"   üìè Raio: {radius_km}km")
    if specialty_name:
        print(f"   ü©∫ Especialidade solicitada: {specialty_name}")
    if doctor_name:
        print(f"   üë®‚Äç‚öïÔ∏è Nome do m√©dico: {doctor_name}")
    
    specialty_id = None
    # Se uma especialidade foi especificada, busca o ID correspondente
    if specialty_name:
        print(f"   üîç Buscando ID da especialidade para: {specialty_name}")
        try:
            # Carrega especialidades m√©dicas do arquivo filtrado
            json_file_path = os.path.join(os.path.dirname(__file__), "medical_specialties.json")
            
            if os.path.exists(json_file_path):
                print("   üìÅ Carregando especialidades m√©dicas do arquivo filtrado...")
                with open(json_file_path, 'r', encoding='utf-8') as file:
                    specialties = json.load(file)
                print(f"   ‚úÖ {len(specialties)} especialidades m√©dicas carregadas do arquivo filtrado")
            else:
                print("   ‚ùå Arquivo de especialidades m√©dicas n√£o encontrado")
                return "Erro: Arquivo de especialidades m√©dicas n√£o encontrado."
            
            specialty_name_lower = specialty_name.lower().strip()
            
            # Busca direta por correspond√™ncia (j√° que o arquivo s√≥ tem especialidades m√©dicas)
            print(f"   üîç Procurando por: {specialty_name_lower}")
            
            matched_specialty = None
            best_match_score = 0
            
            for specialty in specialties:
                specialty_nome_upper = specialty['nome'].upper().strip()
                specialty_nome_lower = specialty['nome'].lower().strip()
                
                # Score de correspond√™ncia
                score = 0
                
                # Correspond√™ncia exata (ignora case)
                if specialty_name_lower == specialty_nome_lower:
                    score = 100
                # Cont√©m o termo completo
                elif specialty_name_lower in specialty_nome_lower:
                    score = 90
                elif specialty_nome_lower in specialty_name_lower:
                    score = 85
                # Busca por palavras-chave parciais
                elif any(word in specialty_nome_lower for word in specialty_name_lower.split() if len(word) > 3):
                    score = 75
                # Busca por in√≠cio do nome
                elif specialty_nome_lower.startswith(specialty_name_lower[:6]):
                    score = 70
                
                # Atualiza melhor correspond√™ncia
                if score > best_match_score:
                    best_match_score = score
                    matched_specialty = specialty
            
            if matched_specialty and best_match_score >= 70:
                specialty_id = matched_specialty['id']
                print(f"   ‚úÖ Especialidade encontrada: {matched_specialty['nome']} (ID: {specialty_id}) - Score: {best_match_score}")
            else:
                print(f"   ‚ö†Ô∏è Especialidade '{specialty_name}' n√£o encontrada com confian√ßa suficiente, buscando sem filtro de especialidade")
                
        except Exception as e:
            print(f"   ‚ùå Erro ao buscar especialidades: {str(e)}")
            print("   ‚ö†Ô∏è Continuando busca sem filtro de especialidade")
    
    try:
        results = client.search_establishments(
            latitude=latitude,
            longitude=longitude,
            radius_km=radius_km,
            specialty_id=specialty_id,
            doctor_name=doctor_name
        )
        if not results:
            print("   ‚ùå Nenhum estabelecimento encontrado")
            return "Nenhum estabelecimento encontrado que atenda aos seus crit√©rios."
        print(f"   ‚úÖ {len(results)} estabelecimento(s) encontrado(s)")
        return json.dumps(results, ensure_ascii=False)
    except Exception as e:
        return f"Erro ao buscar estabelecimentos: {str(e)}"

@tool
def get_establishment_details(cnes_code: str) -> str:
    """Obt√©m informa√ß√µes detalhadas sobre um estabelecimento de sa√∫de espec√≠fico."""
    print(f"üè• EXECUTANDO: get_establishment_details com CNES='{cnes_code}'")
    try:
        details = client.get_establishment_details(cnes_code)
        print(f"   ‚úÖ Detalhes obtidos para estabelecimento {cnes_code}")
        return json.dumps(details, ensure_ascii=False)
    except Exception as e:
        return f"Erro ao buscar detalhes do estabelecimento: {str(e)}"

# Cria os n√≥s do grafo
def chatbot(state: MessagesState) -> MessagesState:
    """N√≥ principal do chatbot que processa mensagens e decide se precisa usar ferramentas."""
    messages = state["messages"]
    
    # Adiciona a mensagem do sistema se ainda n√£o existir
    if not messages or not isinstance(messages[0], SystemMessage):
        system_message = SystemMessage(
            content="""Voc√™ √© um assistente especializado em ajudar usu√°rios a encontrar profissionais de sa√∫de e estabelecimentos m√©dicos no Brasil.

Voc√™ pode ajudar os usu√°rios a buscar m√©dicos e estabelecimentos de sa√∫de baseado em:
1. Localiza√ß√£o/endere√ßo
2. Especialidade m√©dica
3. Nome do m√©dico
4. Dist√¢ncia (raio em km)

Siga estes passos para ajudar o usu√°rio:
1. Primeiro, determine o que o usu√°rio est√° procurando - busca de endere√ßo ou busca de profissional de sa√∫de
2. Se necess√°rio, pergunte por qualquer informa√ß√£o que esteja faltando, como localiza√ß√£o ou especialidade
3. Use a ferramenta apropriada para buscar as informa√ß√µes
4. Apresente os resultados de forma clara e estruturada
5. Ofere√ßa-se para refinar a busca ou obter mais detalhes se necess√°rio

Lembre-se de que todos os endere√ßos e dados de sa√∫de s√£o do Brasil. Sempre responda em portugu√™s brasileiro.
Quando apresentar resultados, seja claro e organize as informa√ß√µes de forma f√°cil de entender.
Se houver muitos resultados, mostre os mais relevantes primeiro e ofere√ßa para mostrar mais se o usu√°rio quiser.

Ferramentas dispon√≠veis:
- search_address: Para buscar endere√ßos e obter coordenadas
- get_specialties: Para listar especialidades m√©dicas dispon√≠veis (carregadas do arquivo filtrado para performance otimizada)
- search_establishments: Para buscar estabelecimentos de sa√∫de pr√≥ximos (busca automaticamente o ID da especialidade do arquivo filtrado)
- get_establishment_details: Para obter detalhes de um estabelecimento espec√≠fico"""
        )
        messages = [system_message] + messages    # Inicializa o modelo de linguagem com ferramentas
    tools = [search_address, get_specialties, search_establishments, get_establishment_details]
    llm = ChatOpenAI(temperature=0, model="gpt-4o-mini", api_key="")
    llm_with_tools = llm.bind_tools(tools)    # Invoca o modelo com as mensagens
    response = llm_with_tools.invoke(messages)
    
    # Verifica se o modelo quer usar ferramentas e exibe informa√ß√µes detalhadas
    if hasattr(response, 'tool_calls') and response.tool_calls:
        print(f"üîß FERRAMENTAS CHAMADAS: {len(response.tool_calls)} ferramenta(s)")
        for i, tool_call in enumerate(response.tool_calls, 1):
            tool_name = tool_call['name']
            tool_args = tool_call.get('args', {})
            print(f"   {i}. üìã {tool_name}")
            if tool_args:
                for key, value in tool_args.items():
                    print(f"      - {key}: {value}")
        print("‚û°Ô∏è DIRECIONANDO para execu√ß√£o das ferramentas...")
    else:
        print("üèÅ FINALIZANDO resposta (sem ferramentas necess√°rias)")
    
    # Atualiza as mensagens
    updated_messages = messages + [response]
    
    return {"messages": updated_messages}

def should_continue(state: MessagesState) -> str:
    """Decide se deve continuar para as ferramentas ou finalizar."""
    messages = state["messages"]
    last_message = messages[-1]
    
    # Se a √∫ltima mensagem tem tool_calls, vai para as ferramentas
    if hasattr(last_message, 'tool_calls') and last_message.tool_calls:
        return "tools"
    # Sen√£o, finaliza
    return END

# Cria o grafo
def create_agent_graph() -> StateGraph:
    """Cria o grafo do agente LangGraph."""
    workflow = StateGraph(MessagesState)    # Cria as ferramentas dispon√≠veis
    tools = [search_address, get_specialties, search_establishments, get_establishment_details]
    tool_node = ToolNode(tools)
    
    # Adiciona n√≥s
    workflow.add_node("chatbot", chatbot)
    workflow.add_node("tools", tool_node)
    
    # Define o ponto de entrada
    workflow.set_entry_point("chatbot")
    
    # Adiciona arestas condicionais
    workflow.add_conditional_edges(
        "chatbot",
        should_continue,
        {
            "tools": "tools",
            END: END
        }
    )
    
    # Ap√≥s usar ferramentas, volta para o chatbot
    workflow.add_edge("tools", "chatbot")
    
    return workflow

# Inicializa o agente com MemorySaver
memory = MemorySaver()
agent_graph = create_agent_graph()
agent = agent_graph.compile(checkpointer=memory)

def ask_agent(user_input: str, thread_id: str = "02") -> Dict[str, Any]:
    """Fun√ß√£o para interagir com o agente."""
    
    print(f"\nü§ñ INICIANDO PROCESSAMENTO: '{user_input}'")
    print(f"üì± Thread ID: {thread_id}")
    
    # Configura√ß√£o da thread para persist√™ncia
    config = {"configurable": {"thread_id": thread_id}}
    
    # Cria a mensagem do usu√°rio
    user_message = HumanMessage(content=user_input)
      # Executa o agente com configura√ß√£o de thread
    result = agent.invoke({"messages": [user_message]}, config=config)
    
    # Extrai a resposta final (√∫ltima mensagem AI)
    final_messages = result["messages"]
    response_content = ""
    
    # Busca pela √∫ltima mensagem AI que n√£o seja de ferramenta
    for msg in reversed(final_messages):
        if isinstance(msg, AIMessage):
            # Se n√£o tem tool_calls ou se tem conte√∫do
            if not hasattr(msg, 'tool_calls') or not msg.tool_calls or msg.content:
                response_content = msg.content
                break
    
    print(f"‚úÖ PROCESSAMENTO CONCLU√çDO - Resposta pronta!")
    print("-" * 50)
    
    return {
        "response": response_content,
        "thread_id": thread_id
    }